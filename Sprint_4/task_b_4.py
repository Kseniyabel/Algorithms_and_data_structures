# https://contest.yandex.ru/contest/24414/run-report/84603677/

''' Принцип работы:
В данной задаче необходимо реализовать структуру данных - 
хеш-таблица. Она представляет собой неупорядоченную коллекцию 
пар "ключ-значение". В данном случае хеш-таблица реализована
при помощи списка кортежей (None, None): 0 элемент - ключ, 1 - 
значение.  При добавлении пары ключ-значение (put), вычисляется хеш-
функция ключа (при помощи остатка от деления на длину массива),
полученное значение - индекс в массиве коретжей. По данному индексу
записывается пара ключ-значение. Если же по данному индексу в
массиве находится другой ключ (т.е. произошла коллизия),
используется метод открытой адрессации, стратегия линейного 
пробирования с функцией повторного хеширования. Пока не найдется
свободная ячейка в массиве или ячейка с нужным ключом,
будет вычисляться новое значение индекса (new_hash), 
как только такое значение найдено, записывается пара ключ-значение. 
По схожему принципу работают методы get и delete.

Доказательство корректности:
В данном случае выполнены все основные требования для хеш-
таблицы. Пары ключ-значение хранятся в tuple (однозначное сопоставление
ключей и значений). Доступ к данным осуществляется по индексу в массиве
(определяется хеш-функцией).
Коллизии разрешаются методом открытой адрессации (линейное пробирование с
функцией повторного хеширования).

Временная сложность:
В лучшем случае операции выполняются за O(1): константное время для вычисления
реузальтата хеш-функции, константное время доступа к элементу по индексу.
Сложность зависит от коэффициента заполенения (количество элементов/количество 
корзин).В лучшем случае, если таблица заполнена на 1/3 - 2/3, коллизии 
будут возникать редко, все элементы хранятся на своих местах, сложность O(1).
Если коэффициент заполнения возрастает, увеличивается и вероятность коллизий, 
соответственно поиск свободной ячейки для добавления и поиск элемента будут
занимать больше времени. В данной реализации для хранения данных используется 
непрерывный массив (метод открытой адрессации), могут образовываться кластеры.
В среднем время добавления, поиска и удаления элемента будет O(1 / 1 - a), 
где а - коэффициент заполнения. В худшем случае - O(n).

Пространственная сложность:
Если размер таблицы равен n, то пространственная сложность O(n).
'''

class OwnHashTab:
    def __init__(self, size=10**5):
        self.size = size
        self.tab = [(None, None)] * self.size

    def hash_f(self, key):
        return key % self.size
    
    def new_hash(self, old_hash):
        return (old_hash + 1) % self.size
    
    def new_index(self, key):
        index = self.hash_f(key)
        while self.tab[index][0] is not None and self.tab[index][0] != key:
            index = self.new_hash(index)
        return index

    def put(self, key, value):
        index = self.new_index(key)
        self.tab[index] = (key, value)

    def get(self, key):
        index = self.new_index(key)
        if self.tab[index][0] == key:
            return self.tab[index][1]
        else:
            return None
    
    def delete(self, key):
        index = self.new_index(key)
        if self.tab[index][0] == key:
            val = self.tab[index][1]
            self.tab[index] = (None, None)
            return val
        else:
            return None
        

def main() -> None:
    n = int(input())
    hash_tab = OwnHashTab(n)

    for _ in range(n):
        cmd = input().split()
        if len(cmd) == 2:
            print(getattr(hash_tab, cmd[0])(int(cmd[1])))
        else:
            getattr(hash_tab, cmd[0])(*map(int, cmd[1:]))

if __name__ == '__main__':
    main()